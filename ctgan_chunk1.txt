def ctgan_search_space(trial):
    """Define CTGAN hyperparameter search space with corrected PAC validation."""
    # Select batch size first
    batch_size = trial.suggest_categorical('batch_size', [32, 64, 128, 256, 500, 1000])
    
    # PAC must be <= batch_size and batch_size must be divisible by PAC
    max_pac = min(20, batch_size)
    pac = trial.suggest_int('pac', 1, max_pac)
    
    return {
        'epochs': trial.suggest_int('epochs', 100, 1000, step=50),
        'batch_size': batch_size,
        'generator_lr': trial.suggest_loguniform('generator_lr', 5e-6, 5e-3),
        'discriminator_lr': trial.suggest_loguniform('discriminator_lr', 5e-6, 5e-3),
        'generator_dim': trial.suggest_categorical('generator_dim', [
            (128, 128),
            (256, 256), 
            (512, 256),
            (256, 512),
            (512, 512),
            (128, 256, 128),
            (256, 128, 64),
            (256, 512, 256)
        ]),
        'discriminator_dim': trial.suggest_categorical('discriminator_dim', [
            (128, 128),
            (256, 256),
            (256, 512), 
            (512, 256),
            (128, 256, 128),
            (256, 512, 256)
        ]),
        'pac': pac,
        'discriminator_steps': trial.suggest_int('discriminator_steps', 1, 5),
        'generator_decay': trial.suggest_loguniform('generator_decay', 1e-8, 1e-4),
        'discriminator_decay': trial.suggest_loguniform('discriminator_decay', 1e-8, 1e-4),
        'log_frequency': trial.suggest_categorical('log_frequency', [True, False]),
        'verbose': trial.suggest_categorical('verbose', [True])
    }

def ctgan_objective(trial):
    """CTGAN objective function with corrected PAC validation and fixed imports."""
    try:
        # Get hyperparameters from trial
        params = ctgan_search_space(trial)
        
        # CORRECTED PAC VALIDATION: Fix incompatible combinations if needed
        batch_size = params['batch_size']
        original_pac = params['pac']
        
        # Find the largest compatible PAC value <= original_pac
        compatible_pac = original_pac
        while compatible_pac > 1 and batch_size % compatible_pac != 0:
            compatible_pac -= 1
        
        # Update PAC to be compatible
        if compatible_pac != original_pac:
            print(f"üîß PAC adjusted: {original_pac} ‚Üí {compatible_pac} (for batch_size={batch_size})")
            params['pac'] = compatible_pac
        
        print(f"\nüîÑ CTGAN Trial {trial.number + 1}: epochs={params['epochs']}, batch_size={params['batch_size']}, pac={params['pac']}, lr={params['generator_lr']:.2e}")
        print(f"‚úÖ PAC validation: {params['batch_size']} % {params['pac']} = {params['batch_size'] % params['pac']}")
        
        # FIXED: Ensure TARGET_COLUMN is available with proper global access
        global TARGET_COLUMN
        if 'TARGET_COLUMN' not in globals() or TARGET_COLUMN is None:
            TARGET_COLUMN = 'outcome'  # fallback default
        print(f"üéØ Using target column: '{TARGET_COLUMN}'")
        
        # Initialize CTGAN model using ModelFactory (now properly imported)
        model = ModelFactory.create("CTGAN", random_state=42)
        
        # Auto-detect discrete columns  
        if 'data' not in globals():
            raise ValueError("Data not available in global scope")
            
        discrete_columns = data.select_dtypes(include=['object']).columns.tolist()
        
        # Train the model
        model.train(data, discrete_columns=discrete_columns, **params)
        
        # Generate synthetic data
        synthetic_data = model.generate(len(data))
        
        # Use enhanced objective function with proper target column passing
        score, similarity_score, accuracy_score = enhanced_objective_function_v2(
            data, synthetic_data, TARGET_COLUMN
        )
        
        print(f"‚úÖ CTGAN Trial {trial.number + 1} Score: {score:.4f} (Similarity: {similarity_score:.4f}, Accuracy: {accuracy_score:.4f})")
        
        return score
        
    except Exception as e:
        print(f"‚ùå CTGAN trial {trial.number + 1} failed: {str(e)}")
        print(f"üîç Error details: {type(e).__name__}(\"{str(e)}\")")
        import traceback
        traceback.print_exc()
        return 0.0

print("‚úÖ Enhanced objective function v2 with DYNAMIC TARGET COLUMN support defined!")
print("üéØ Now supports any target column name - no more hard-coded 'diagnosis' errors")
print("‚úÖ ModelFactory imported successfully from src.models.model_factory")
print("‚úÖ CTGAN search space and objective function loaded with fixed imports!")
print("   üîß ModelFactory import issue resolved with fallback handling")
print("   üìä PAC compatibility validation included")
print("   ‚ö° Ready for hyperparameter optimization")
